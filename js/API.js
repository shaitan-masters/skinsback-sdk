"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
const SignatureGenerator_1 = require("./SignatureGenerator");
const defaultConfig_1 = require("./defaultConfig");
const types_1 = require("./types");
const Trace_1 = __importDefault(require("./Trace"));
class API {
    constructor(apiConfig) {
        this.getBalance = () => {
            return this.axios.post('', { method: types_1.API_METHODS.BALANCE });
        };
        this.getCurrencies = () => {
            return this.axios.post('', { method: types_1.API_METHODS.GET_CURRENCIES });
        };
        this.getOrders = ({ starting, ending }) => {
            return this.axios.post('', { starting, ending, method: types_1.API_METHODS.GET_ORDERS });
        };
        this.getOrderStatusByTransactionId = (transaction_id) => {
            return this.axios.post('', { transaction_id, method: types_1.API_METHODS.GET_ORDER_STATUS });
        };
        this.getOrderStatusByOrderId = (order_id) => {
            return this.axios.post('', { order_id, method: types_1.API_METHODS.GET_ORDER_STATUS });
        };
        this.createOrder = (order_id) => {
            return this.axios.post('', { order_id, method: types_1.API_METHODS.CREATE_ORDER });
        };
        this.serverStatus = () => {
            return this.axios.post('', { method: types_1.API_METHODS.GET_SERVER_STATUS });
        };
        this.getErrorCallbackList = () => {
            return this.axios.post('', { method: types_1.API_METHODS.GET_ERROR_CALLBACK_ERROR_LIST });
        };
        this.getMarketPriceList = (game = 'csgo') => {
            return this.axios.post('', { game, method: types_1.API_METHODS.GET_MARKET_PRICE_LIST });
        };
        this.findItemsByName = (name, game = 'csgo') => {
            return this.axios.post('', { name, game, method: types_1.API_METHODS.SEARCH_ITEMS });
        };
        this.buyItemByNameAndSendToUser = (data) => {
            return this.axios.post('', { ...data, method: types_1.API_METHODS.BUY_ITEM_AND_SEND });
        };
        this.buyItemByIdAndSendToUser = (data) => {
            return this.axios.post('', { ...data, method: types_1.API_METHODS.BUY_ITEM_AND_SEND });
        };
        this.getInfoAboutBoughtItem = (buy_id) => {
            return this.axios.post('', { buy_id, method: types_1.API_METHODS.GET_INFO_ABOUT_BOUGHT_ITEM });
        };
        this.getBoughtItemsHistory = ({ starting, ending }) => {
            return this.axios.post('', { starting, ending, method: types_1.API_METHODS.GET_INFO_ABOUT_BOUGHT_ITEM });
        };
        this.config = apiConfig;
        this.axios = axios_1.default.create({
            baseURL: this.config.apiUrl || defaultConfig_1.API_URL,
        });
        this.trace = null;
        if (this.config.enableLogs) {
            this.trace = new Trace_1.default({
                logsPath: this.config.logsPath,
                excludeMethods: this.config.excludeMethods,
                amountOfLastDaysOfSavingLogs: this.config.amountOfLastDaysOfSavingLogs
            });
        }
        API.interceptorsInit.call(this, this.config, this.trace);
    }
    static interceptorsInit(apiConfig, trace) {
        this.axios.interceptors.request.use((config) => {
            // Adding shop_id field to requests body and
            // adding sign field generated by SignatureBuilder service
            const data = {
                ...config.data,
                shopid: apiConfig.shop_id,
            };
            data.sign = SignatureGenerator_1.SignatureApiBuilder(data, apiConfig.secret_key);
            config.data = data;
            // Return modified config with shop_id and signature
            return config;
        }, error => {
            // Write response data with error to logs
            trace && trace.logError(error);
            return Promise.reject(error);
        });
        // Response interceptor
        this.axios.interceptors.response.use((response) => {
            // When received error, response has status 200? but it has status field in response body with error
            // or fail status. Interceptor checks status in response body and call reject if
            // status fail or error and write Promise value as response body
            if (response.data.status === 'error' || response.data.status === 'fail') {
                // Write response data with error to logs
                trace && trace.logResponseError(response);
                return Promise.reject(response);
            }
            // Write response data with data to logs
            trace && trace.logResponse(response);
            return response.data;
        }, error => {
            // Write response data with error to logs
            trace && trace.logError(error);
            return Promise.reject(error);
        });
    }
}
exports.default = API;
